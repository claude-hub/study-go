1. printf()、与fmt.printf()区别。

2. 对于全局变量，如何声明？如果全部都是大写，那么对外部包就是可见的。如果只对当前包可见，如何声明。

3. 在循环中使用加号	“+”拼接字符串并不是最高效的做法，更好的办法是使用函数`strings.Join()`，有 没有更好地办法了？有！使用字节缓冲（`bytes.Buffer`）拼接更加给力

4. new() 和 make() 的区别

   - new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 **返回一个指向类型为 T，值为 0 的地址的指针**，它适用于值类型如数组和结构体；它相当于 `&T{}`。
   - make(T) **返回一个类型为 T 的初始值**，它只适用于3种内建的引用类型：切片、map 和 channel。

5. 重新声明与再次赋值

   ~~~go
   f, err := os.Open(name)
   if err != nil {
       return err
   }
   d, err := f.Stat()
   if err != nil {
       f.Close()
       return err
   }
   ~~~

   调用了 `f.Stat`。它看起来似乎是声明了 `d` 和 `err`。 注意，尽管两个语句中都出现了 `err`，但这种重复仍然是合法的：`err` 在第一条语句中被声明，但在第二条语句中只是被**再次赋值**罢了。也就是说，调用 `f.Stat` 使用的是前面已经声明的 `err`，它只是被重新赋值了而已。

   ~~~go
   if b := 1; b > 2 {
   
   } else {
       b = 3 //这是if声明的b
       fmt.Println(b)
       b := "str"  //这里是新声明的一个b，if语句里面声明的b，在这里被隐藏掉了
       fmt.Println(b)
   }
   ~~~

   在满足下列条件时，已被声明的变量 `v` 可出现在`:=` 声明中：

   - 本次声明与已声明的 `v` 处于同一作用域中（若 `v` 已在外层作用域中声明过，则此次声明会创建一个新的变量），
   - 在初始化中与其类型相应的值才能赋予 `v`
   - 在此次声明中至少另有一个变量是新声明的。

6. for循环

   ~~~go
   for i, j := 0, 10; i < 10 && j > 0; i, j = i+1, j-1 {//使用多个变量控制循环
   }
   ~~~
